**Read in other languages: [Русский](README.md), [Polska](README.pl.md).**

# React homework template

Этот проект был создан при помощи
[Create React App](https://github.com/facebook/create-react-app). Для знакомства
и настройки дополнительных возможностей
[обратись к документации](https://facebook.github.io/create-react-app/docs/getting-started).

## Подготовка нового проекта

1. Убедись что на компьютере установлена LTS-версия Node.js.
   [Скачай и установи](https://nodejs.org/en/) её если необходимо.
2. Склонируй этот репозиторий.
3. Измени имя папки с `react-homework-template` на имя своего проекта.
4. Создай новый пустой репозиторий на GitHub.
5. Открой проект в VSCode, запусти терминал и свяжи проект с GitHub-репозиторием
   [по инструкции](https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories#changing-a-remote-repositorys-url).
6. Установи базовые зависимости проекта командой `npm install`.
7. Запусти режим разработки, выполнив команду `npm start`.
8. Перейди в браузере по адресу [http://localhost:3000](http://localhost:3000).
   Эта страница будет автоматически перезагружаться после сохранения изменений в
   файлах проекта.

## Деплой

Для настройки деплоя проекта необходимо выполнить несколько дополнительных шагов
по настройке твоего репозитория. Зайди во вкладку `Settings` и в подсекции
`Actions` выбери выбери пункт `General`.

![GitHub actions settings](./assets/actions-config-step-1.png)

Пролистай страницу до последней секции, в которой выбери опции как на следующем
изображении и нажми `Save`. Без этих настроек у сборки будет недостаточно прав
для автоматизации процесса деплоя.

![GitHub actions settings](./assets/actions-config-step-2.png)

Продакшн версия проекта будет автоматически проходить линтинг, собираться и
деплоиться на GitHub Pages, в ветку `gh-pages`, каждый раз когда обновляется
ветка `main`. Например, после прямого пуша или принятого пул-реквеста. Для этого
необходимо в файле `package.json` отредактировать поле `homepage`, заменив
`your_username` и `your_repo_name` на свои, и отправить изменения на GitHub.

```json
"homepage": "https://your_username.github.io/your_repo_name/"
```

Далее необходимо зайти в настройки GitHub-репозитория (`Settings` > `Pages`) и
выставить раздачу продакшн версии файлов из папки `/root` ветки `gh-pages`, если
это небыло сделано автоматически.

![GitHub Pages settings](./assets/repo-settings.png)

### Статус деплоя

Статус деплоя крайнего коммита отображается иконкой возле его идентификатора.

- **Желтый цвет** - выполняется сборка и деплой проекта.
- **Зеленый цвет** - деплой завершился успешно.
- **Красный цвет** - во время линтинга, сборки или деплоя произошла ошибка.

Более детальную информацию о статусе можно посмотреть кликнув по иконке, и в
выпадающем окне перейти по ссылке `Details`.

![Deployment status](./assets/status.png)

### Живая страница

Через какое-то время, обычно пару минут, живую страницу можно будет посмотреть
по адресу указанному в отредактированном свойстве `homepage`. Например, вот
ссылка на живую версию для этого репозитория
[https://goitacademy.github.io/react-homework-template](https://goitacademy.github.io/react-homework-template).

Если открывается пустая страница, убедись что во вкладке `Console` нет ошибок
связанных с неправильными путями к CSS и JS файлам проекта (**404**). Скорее
всего у тебя неправильное значение свойства `homepage` в файле `package.json`.

### Маршрутизация

Если приложение использует библиотеку `react-router-dom` для маршрутизации,
необходимо дополнительно настроить компонент `<BrowserRouter>`, передав в пропе
`basename` точное название твоего репозитория. Слеши в начале и конце строки
обязательны.

```jsx
<BrowserRouter basename="/your_repo_name/">
  <App />
</BrowserRouter>
```

## Как это работает

![How it works](./assets/how-it-works.png)

1. После каждого пуша в ветку `main` GitHub-репозитория, запускается специальный
   скрипт (GitHub Action) из файла `.github/workflows/deploy.yml`.
2. Все файлы репозитория копируются на сервер, где проект инициализируется и
   проходит линтинг и сборку перед деплоем.
3. Если все шаги прошли успешно, собранная продакшн версия файлов проекта
   отправляется в ветку `gh-pages`. В противном случае, в логе выполнения
   скрипта будет указано в чем проблема.

   ***

4. Модалка - в состояние класса Апп записываем свойство showModal: false.
   Создаем публичное свойство, изменяющее значение showModal на противоположное
   и передаем его в onClick на кнопку (изображение, оверлей).

5. Методы жизненного цикла компонента лучше ставить сразу после стейта. Внутрь
   модалки добавляем пропс this.props.children - теперь это переиспользуемый
   компонент. В нем может быть много всяких children.

6. Для всех компонентов, которые всплывают поверх контента (модалка, нотификации
   и т.д.), удобно использовать ПОРТАЛ вместо z-index. В index.html под корневым
   создаем новый div с уникальным id, где и будет рендериться разметка
   компонента (но компонент стоит на своём месте, в корневом компненте). Затем в
   файле компонента

import { createPortal } from 'react-dom'; const modalRoot =
document.querySelector('#modal-root'); render() { return createPortal(

<div className={css.Overlay}>
<div className={css.Modal}>{this.props.children}</div> </div>, modalRoot ); }

Возвращаем метод: 1 аргумент - разметка, 2 аргумент - доступ к айди.

7. Чтобы закрыть модалку по нажатию на клавишу, нам надо повесить слушатель на
   window. Это осущестляется на этапе монтирования componentDidMount()

   e.code === 'Escape' - проверка для нажжатия на определенную клавишу

8. !Обязательно необходимо снять слушатель при размонтировании элемента
   componentWillUnmount - метод очистки за собой. В него мы передаем функцию
   тоггла (если она была анонимная, то придется ее сделать методом класса).

9. При клике на бекдроп обязательно должна стоять проверка, которая предотвратит
   закрытие модалки по клику на содержимое, а не бекдропа (так происходит из-за
   всплытия события).

   e.currentTarget === e.target

10. Проблемы с производительностью. Если элемент скрывается (размонтируется), но
    при этом продолжает осуществляться рассчет (например, таймер), то произойдет
    УТЕЧКА ПАМЯТИ. Необходимо всегда снимать HTTP-запросы, слушатели, таймауты,
    интервалы и тд в методе componentWillUnmount(). Иначе вкладка будет падать.

11. ПАТТЕРН РАБОТЫ С КОЛЛЕКЦИЕЙ. Трекаем активный элемент, сетим его индекс (его
    разметку будем рендерить).

12. ОПТИМИЗАЦИЯ. Если компонент был зарендерен по условию, и этого достаточно
    (заново перерендеривать одно и то же не имеет смысла), тогда необходимо
    восползоваться методом

    shouldComponentUpdate(nextProps, nextState) {}

    который вызывается перед ре-рендером уже смонтированного компонента и
    проверяет необходимость дальнейшего ре-рендера компонента

    Проверка:

    return nextState.activeIndex !== this.state.activeIndex

если true - перерендерит, false - рендера не будет. !!!Этод способ используем
крайне редко

АЛЬТЕРНАТИВА: наследовать класс не от Component, а от PureComponent, где под
капотом уже есть shouldComponentUpdate. Там происходит проверка каждого свойства
стейта строгим сравнением.

---

Компоненты: форма, апп и галлерея. В форме мы создаем локальный стейт, где
храним данные инпута (контролируемый элемент). По сабмиту формы, мы передаем в
апп пропсом те данные, которые необхожимо будет использовать для рендера. Из
аппа эти данные пропсом передаются в галлерею, где и будут рендериться.

---

Прокидываем данные из формы в апп в App.jsx при сабмите

handleFormSubmit = inputValue => { console.log(inputValue); };

<Searchbar onSubmitProp={this.handleFormSubmit} />

В Searchbar.jsx

submitHandle = event => { event.preventDefault();
this.props.onSubmitProp(this.state.input); };

---

Не забыть очистить форму после сабмита:

reset = () => { this.setState({ input: '', }); };

---

trim() - обрезать у строки пробелы с обеих сторон

---

нотификации через Тостифай npm i react-toastify

---

ОБРАБОТКА ОШИБОК

1. Храним в стейте, ловим через catch. Ошибка 404.

state = { imagesArray: null, loading: false, error: null, };

.then(response => { if (response.ok) { return response.json(); } return
Promise.reject(new Error(this.props.errorMessage())); })

        errorMessage() - приходит из пропса (Тоастер-нотификация)

.catch(error => { this.setState({ error: error }); // this.props.errorMessage();
})

2.
